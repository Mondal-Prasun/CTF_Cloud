package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/client"
	"github.com/docker/go-connections/nat"
)

type UserSession struct {
	UserID       string `json:"user_id"`
	KaliVNCURL   string `json:"kali_vnc_url"`
	CTFBoxAccess string `json:"ctf_box_access"`
}

var userSessions = make(map[string]UserSession)
var mutex sync.Mutex

func startContainer(cli *client.Client, imageName string, cmd []string, exposedPorts map[string]string, networkID string) (string, string, error) {
	ctx := context.Background()

	// Pull the image if not already available
	_, err := cli.ImagePull(ctx, imageName, types.ImagePullOptions{})
	if err != nil {
		return "", "", fmt.Errorf("failed to pull image %s: %v", imageName, err)
	}

	// Expose ports dynamically
	portBindings := nat.PortMap{}
	for containerPort, hostPort := range exposedPorts {
		portBindings[nat.Port(containerPort)] = []nat.PortBinding{
			{HostPort: hostPort},
		}
	}

	// Create the container
	resp, err := cli.ContainerCreate(ctx, &container.Config{
		Image:        imageName,
		Cmd:          cmd,
		ExposedPorts: nat.PortSet{},
	}, &container.HostConfig{
		PortBindings: portBindings,
		NetworkMode:  container.NetworkMode(networkID),
	}, nil, nil, "")
	if err != nil {
		return "", "", fmt.Errorf("failed to create container: %v", err)
	}

	// Start the container
	if err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{}); err != nil {
		return "", "", fmt.Errorf("failed to start container: %v", err)
	}

	// Get the container's public access details
	publicURL := fmt.Sprintf("http://localhost:%s", exposedPorts["8080"])
	return resp.ID, publicURL, nil
}

func handler(w http.ResponseWriter, r *http.Request) {
	// Extract user ID (could be from a query param, header, etc.)
	userID := r.URL.Query().Get("user_id")
	if userID == "" {
		http.Error(w, "User ID is required", http.StatusBadRequest)
		return
	}

	mutex.Lock()
	defer mutex.Unlock()

	// Check if the user already has a session
	if session, exists := userSessions[userID]; exists {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(session)
		return
	}

	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		http.Error(w, fmt.Sprintf("Docker client error: %v", err), http.StatusInternalServerError)
		return
	}

	// Create a private network for the user
	networkID := fmt.Sprintf("network-%s", userID)
	_, err = cli.NetworkCreate(context.Background(), networkID, types.NetworkCreate{
		CheckDuplicate: true,
	})
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to create network: %v", err), http.StatusInternalServerError)
		return
	}

	// Start the Kali Linux container with VNC
	kaliID, kaliVNCURL, err := startContainer(cli, "kalilinux/kali-rolling", []string{
		"sh", "-c", "vncserver :1 && websockify --web=/usr/share/novnc/ 8080 localhost:5901",
	}, map[string]string{
		"8080": fmt.Sprintf("%d", 8000+len(userSessions)*2+1), // Dynamic port
	}, networkID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to start Kali container: %v", err), http.StatusInternalServerError)
		return
	}

	// Start the CTF box container
	ctfID, ctfAccessURL, err := startContainer(cli, "ubuntu:20.04", []string{
		"sh", "-c", "service apache2 start",
	}, map[string]string{
		"80": fmt.Sprintf("%d", 8000+len(userSessions)*2+2), // Dynamic port
	}, networkID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to start CTF container: %v", err), http.StatusInternalServerError)
		return
	}

	// Save the session
	session := UserSession{
		UserID:       userID,
		KaliVNCURL:   kaliVNCURL,
		CTFBoxAccess: ctfAccessURL,
	}
	userSessions[userID] = session

	// Respond with details
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(session)

	log.Printf("Started containers for user %s: Kali(%s), CTF(%s)", userID, kaliID, ctfID)
	log.Printf("Access URLs: Kali VNC(%s), CTF(%s)", kaliVNCURL, ctfAccessURL)
}

func main() {
	http.HandleFunc("/", handler)
	log.Println("Server running on http://localhost:8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
